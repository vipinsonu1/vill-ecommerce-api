"use strict";
var Promise = require("bluebird");
var MapProxy_1 = require("./MapProxy");
var SetProxy_1 = require("./SetProxy");
var ClientCreateProxyCodec_1 = require("../codec/ClientCreateProxyCodec");
var ClientDestroyProxyCodec_1 = require("../codec/ClientDestroyProxyCodec");
var ClientAddDistributedObjectListenerCodec_1 = require("../codec/ClientAddDistributedObjectListenerCodec");
var ClientRemoveDistributedObjectListenerCodec_1 = require("../codec/ClientRemoveDistributedObjectListenerCodec");
var QueueProxy_1 = require("./QueueProxy");
var ListProxy_1 = require("./ListProxy");
var LockProxy_1 = require("./LockProxy");
var MultiMapProxy_1 = require("./MultiMapProxy");
var RingbufferProxy_1 = require("./RingbufferProxy");
var ReplicatedMapProxy_1 = require("./ReplicatedMapProxy");
var NearCachedMapProxy_1 = require("./NearCachedMapProxy");
var SemaphoreProxy_1 = require("./SemaphoreProxy");
var AtomicLongProxy_1 = require("./AtomicLongProxy");
var LoggingService_1 = require("../logging/LoggingService");
var InvocationService_1 = require("../invocation/InvocationService");
var ProxyManager = (function () {
    function ProxyManager(client) {
        this.MAP_SERVICE = 'hz:impl:mapService';
        this.SET_SERVICE = 'hz:impl:setService';
        this.LOCK_SERVICE = 'hz:impl:lockService';
        this.QUEUE_SERVICE = 'hz:impl:queueService';
        this.LIST_SERVICE = 'hz:impl:listService';
        this.MULTIMAP_SERVICE = 'hz:impl:multiMapService';
        this.RINGBUFFER_SERVICE = 'hz:impl:ringbufferService';
        this.REPLICATEDMAP_SERVICE = 'hz:impl:replicatedMapService';
        this.SEMAPHORE_SERVICE = 'hz:impl:semaphoreService';
        this.ATOMICLONG_SERVICE = 'hz:impl:atomicLongService';
        this.service = {
            'hz:impl:mapService': MapProxy_1.MapProxy,
            'hz:impl:setService': SetProxy_1.SetProxy,
            'hz:impl:queueService': QueueProxy_1.QueueProxy,
            'hz:impl:listService': ListProxy_1.ListProxy,
            'hz:impl:lockService': LockProxy_1.LockProxy,
            'hz:impl:multiMapService': MultiMapProxy_1.MultiMapProxy,
            'hz:impl:ringbufferService': RingbufferProxy_1.RingbufferProxy,
            'hz:impl:replicatedMapService': ReplicatedMapProxy_1.ReplicatedMapProxy,
            'hz:impl:semaphoreService': SemaphoreProxy_1.SemaphoreProxy,
            'hz:impl:atomicLongService': AtomicLongProxy_1.AtomicLongProxy
        };
        this.proxies = {};
        this.logger = LoggingService_1.LoggingService.getLoggingService();
        this.client = client;
        this.invocationTimeoutMillis = this.client.getInvocationService().getInvocationTimeoutMillis();
        this.invocationRetryPauseMillis = this.client.getInvocationService().getInvocationRetryPauseMillis();
    }
    ProxyManager.prototype.getOrCreateProxy = function (name, serviceName, createAtServer) {
        if (createAtServer === void 0) { createAtServer = true; }
        if (this.proxies[name]) {
            return this.proxies[name];
        }
        else {
            var newProxy;
            if (serviceName === this.MAP_SERVICE && this.client.getConfig().nearCacheConfigs[name]) {
                newProxy = new NearCachedMapProxy_1.NearCachedMapProxy(this.client, serviceName, name);
            }
            else {
                newProxy = new this.service[serviceName](this.client, serviceName, name);
            }
            if (createAtServer) {
                this.createProxy(newProxy);
            }
            this.proxies[name] = newProxy;
            return newProxy;
        }
    };
    ProxyManager.prototype.createProxy = function (proxyObject) {
        var promise = Promise.defer();
        this.initializeProxy(proxyObject, promise, Date.now() + this.invocationTimeoutMillis);
        return promise.promise;
    };
    ProxyManager.prototype.findNextAddress = function () {
        var members = this.client.getClusterService().getMembers();
        var liteMember = null;
        for (var i = 0; i < members.length; i++) {
            var currentMember = members[i];
            if (currentMember != null && currentMember.isLiteMember === false) {
                return currentMember.address;
            }
            else if (currentMember != null && currentMember.isLiteMember) {
                liteMember = currentMember;
            }
        }
        if (liteMember != null) {
            return liteMember.address;
        }
        else {
            return null;
        }
    };
    ProxyManager.prototype.initializeProxy = function (proxyObject, promise, deadline) {
        var _this = this;
        if (Date.now() <= deadline) {
            var address = this.findNextAddress();
            var request = ClientCreateProxyCodec_1.ClientCreateProxyCodec.encodeRequest(proxyObject.getName(), proxyObject.getServiceName(), address);
            var invocation = new InvocationService_1.Invocation(this.client, request);
            invocation.address = address;
            this.client.getInvocationService().invoke(invocation).then(function (response) {
                promise.resolve(response);
            }).catch(function (error) {
                _this.logger.warn('ProxyManager', 'Create proxy request for ' + proxyObject.getName() +
                    ' failed. Retrying in ' + _this.invocationRetryPauseMillis + 'ms.');
                setTimeout(_this.initializeProxy.bind(_this, proxyObject, promise, deadline), _this.invocationRetryPauseMillis);
            });
        }
        else {
            promise.reject('Create proxy request timed-out for ' + proxyObject.getName());
        }
    };
    ProxyManager.prototype.destroyProxy = function (name, serviceName) {
        delete this.proxies[name];
        var clientMessage = ClientDestroyProxyCodec_1.ClientDestroyProxyCodec.encodeRequest(name, serviceName);
        clientMessage.setPartitionId(-1);
        return this.client.getInvocationService().invokeOnRandomTarget(clientMessage).then(function () {
            return;
        });
    };
    ProxyManager.prototype.addDistributedObjectListener = function (listenerFunc) {
        var handler = function (clientMessage) {
            var converterFunc = function (name, serviceName, eventType) {
                if (eventType === 'CREATED') {
                    listenerFunc(name, serviceName, 'created');
                }
                else if (eventType === 'DESTROYED') {
                    listenerFunc(name, serviceName, 'destroyed');
                }
            };
            ClientAddDistributedObjectListenerCodec_1.ClientAddDistributedObjectListenerCodec.handle(clientMessage, converterFunc, null);
        };
        var codec = this.createDistributedObjectListener();
        return this.client.getListenerService().registerListener(codec, handler);
    };
    ProxyManager.prototype.removeDistributedObjectListener = function (listenerId) {
        return this.client.getListenerService().deregisterListener(listenerId);
    };
    ProxyManager.prototype.createDistributedObjectListener = function () {
        return {
            encodeAddRequest: function (localOnly) {
                return ClientAddDistributedObjectListenerCodec_1.ClientAddDistributedObjectListenerCodec.encodeRequest(localOnly);
            },
            decodeAddResponse: function (msg) {
                return ClientAddDistributedObjectListenerCodec_1.ClientAddDistributedObjectListenerCodec.decodeResponse(msg).response;
            },
            encodeRemoveRequest: function (listenerId) {
                return ClientRemoveDistributedObjectListenerCodec_1.ClientRemoveDistributedObjectListenerCodec.encodeRequest(listenerId);
            }
        };
    };
    return ProxyManager;
}());
module.exports = ProxyManager;
//# sourceMappingURL=ProxyManager.js.map