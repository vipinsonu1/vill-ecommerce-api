"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MapProxy_1 = require("./MapProxy");
var NearCache_1 = require("../nearcache/NearCache");
var Promise = require("bluebird");
var MapAddNearCacheEntryListenerCodec_1 = require("../codec/MapAddNearCacheEntryListenerCodec");
var EntryEventType_1 = require("../core/EntryEventType");
var InvalidationAwareWrapper_1 = require("../nearcache/InvalidationAwareWrapper");
var KeyStateMarker_1 = require("../nearcache/KeyStateMarker");
var DataStoreHashMap_1 = require("../DataStoreHashMap");
var MapRemoveEntryListenerCodec_1 = require("../codec/MapRemoveEntryListenerCodec");
var NearCachedMapProxy = (function (_super) {
    __extends(NearCachedMapProxy, _super);
    function NearCachedMapProxy(client, servicename, name) {
        var _this = _super.call(this, client, servicename, name) || this;
        _this.nearCache = new NearCache_1.NearCacheImpl(_this.client.getConfig().nearCacheConfigs[name], _this.client.getSerializationService());
        _this.keyStateMarker = KeyStateMarker_1.TrueKeyStateMarker.INSTANCE;
        if (_this.nearCache.isInvalidatedOnChange()) {
            var partitionCount = client.getPartitionService().getPartitionCount();
            _this.nearCache = InvalidationAwareWrapper_1.InvalidationAwareWrapper.asInvalidationAware(_this.nearCache, partitionCount);
            _this.keyStateMarker = _this.getKeyStateMarker();
            _this.addNearCacheInvalidationListener().then(function (id) {
                _this.invalidationListenerId = id;
            });
        }
        return _this;
    }
    NearCachedMapProxy.prototype.tryToPutNearCache = function (key, value) {
        try {
            this.nearCache.put(key, value);
        }
        finally {
            this.resetToUnmarkedState(key);
        }
    };
    NearCachedMapProxy.prototype.resetToUnmarkedState = function (key) {
        if (this.keyStateMarker.unmarkIfMarked(key)) {
            return;
        }
        this.nearCache.invalidate(key);
        this.keyStateMarker.unmarkForcibly(key);
    };
    NearCachedMapProxy.prototype.unmarkRemainingMarkedKeys = function (markers) {
        var _this = this;
        var entries = markers.entries();
        entries.forEach(function (entry) {
            var marked = entry[1];
            if (marked) {
                _this.keyStateMarker.unmarkForcibly(entry[0]);
            }
        });
    };
    NearCachedMapProxy.prototype.invalidatCacheEntryAndReturn = function (keyData, retVal) {
        this.nearCache.invalidate(keyData);
        return retVal;
    };
    NearCachedMapProxy.prototype.invalidateCacheAndReturn = function (retVal) {
        this.nearCache.clear();
        return retVal;
    };
    NearCachedMapProxy.prototype.getKeyStateMarker = function () {
        return this.nearCache.getKeyStateMarker();
    };
    NearCachedMapProxy.prototype.clear = function () {
        return _super.prototype.clear.call(this).then(this.invalidateCacheAndReturn.bind(this));
    };
    NearCachedMapProxy.prototype.containsKeyInternal = function (keyData) {
        var cachedValue = this.nearCache.get(keyData);
        if (cachedValue !== undefined) {
            return Promise.resolve(cachedValue != null);
        }
        else {
            return _super.prototype.containsKeyInternal.call(this, keyData);
        }
    };
    NearCachedMapProxy.prototype.deleteInternal = function (keyData) {
        this.nearCache.invalidate(keyData);
        return _super.prototype.deleteInternal.call(this, keyData).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.evictAll = function () {
        this.nearCache.clear();
        return _super.prototype.evictAll.call(this).then(this.invalidateCacheAndReturn.bind(this));
    };
    NearCachedMapProxy.prototype.evictInternal = function (key) {
        return _super.prototype.evictInternal.call(this, key).then(this.invalidatCacheEntryAndReturn.bind(this, key));
    };
    NearCachedMapProxy.prototype.putAllInternal = function (partitionsToKeysData) {
        var _this = this;
        return _super.prototype.putAllInternal.call(this, partitionsToKeysData).then(function () {
            for (var partition in partitionsToKeysData) {
                partitionsToKeysData[partition].forEach(function (entry) {
                    _this.nearCache.invalidate(entry[0]);
                });
            }
        });
    };
    NearCachedMapProxy.prototype.putIfAbsentInternal = function (keyData, valueData, ttl) {
        return _super.prototype.putIfAbsentInternal.call(this, keyData, valueData, ttl).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.putTransientInternal = function (keyData, valueData, ttl) {
        return _super.prototype.putTransientInternal.call(this, keyData, valueData, ttl).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.executeOnKeyInternal = function (keyData, proData) {
        return _super.prototype.executeOnKeyInternal.call(this, keyData, proData).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.putInternal = function (keyData, valueData, ttl) {
        return _super.prototype.putInternal.call(this, keyData, valueData, ttl).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.getInternal = function (keyData) {
        var _this = this;
        var cachedValue = this.nearCache.get(keyData);
        if (cachedValue !== undefined) {
            return Promise.resolve(cachedValue);
        }
        else {
            var marked_1 = this.keyStateMarker.markIfUnmarked(keyData);
            return _super.prototype.getInternal.call(this, keyData).then(function (val) {
                if (marked_1) {
                    _this.tryToPutNearCache(keyData, val);
                }
                return val;
            }).catch(function (err) {
                _this.resetToUnmarkedState(keyData);
                throw err;
            });
        }
    };
    NearCachedMapProxy.prototype.tryRemoveInternal = function (keyData, timeout) {
        return _super.prototype.tryRemoveInternal.call(this, keyData, timeout).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.removeInternal = function (keyData, value) {
        return _super.prototype.removeInternal.call(this, keyData, value).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.getAllInternal = function (partitionsToKeys, result) {
        var _this = this;
        if (result === void 0) { result = []; }
        var markers = new DataStoreHashMap_1.DataKeyedHashMap();
        try {
            for (var partition in partitionsToKeys) {
                var partitionArray = partitionsToKeys[partition];
                for (var i = partitionArray.length - 1; i >= 0; i--) {
                    var key = partitionArray[i];
                    var cachedResult = this.nearCache.get(key);
                    if (cachedResult !== undefined) {
                        result.push([this.toObject(partitionArray[i]), cachedResult]);
                        partitionArray = partitionArray.splice(i, 1);
                    }
                    else if (this.nearCache.isInvalidatedOnChange()) {
                        markers.set(key, this.keyStateMarker.markIfUnmarked(key));
                    }
                }
            }
        }
        catch (err) {
            this.unmarkRemainingMarkedKeys(markers);
            return Promise.resolve([]);
        }
        return _super.prototype.getAllInternal.call(this, partitionsToKeys, result).then(function (serializedEntryArray) {
            try {
                serializedEntryArray.forEach(function (serializedEntry) {
                    var key = serializedEntry[0];
                    var value = serializedEntry[1];
                    var marked = markers.get(key);
                    markers.delete(key);
                    if (marked !== undefined && marked) {
                        _this.tryToPutNearCache(key, value);
                    }
                    else if (!_this.nearCache.isInvalidatedOnChange()) {
                        _this.nearCache.put(key, value);
                    }
                });
            }
            finally {
                _this.unmarkRemainingMarkedKeys(markers);
            }
            return result;
        });
    };
    NearCachedMapProxy.prototype.replaceIfSameInternal = function (keyData, oldValueData, newValueData) {
        return _super.prototype.replaceIfSameInternal.call(this, keyData, oldValueData, newValueData)
            .then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.replaceInternal = function (keyData, valueData) {
        return _super.prototype.replaceInternal.call(this, keyData, valueData).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.setInternal = function (keyData, valueData, ttl) {
        return _super.prototype.setInternal.call(this, keyData, valueData, ttl).then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.tryPutInternal = function (keyData, valueData, timeout) {
        return _super.prototype.tryPutInternal.call(this, keyData, valueData, timeout)
            .then(this.invalidatCacheEntryAndReturn.bind(this, keyData));
    };
    NearCachedMapProxy.prototype.addNearCacheInvalidationListener = function () {
        var nearCache = this.nearCache;
        var invalidationHandler = function (keyData) {
            if (keyData == null) {
                nearCache.clear();
            }
            else {
                nearCache.invalidate(keyData);
            }
        };
        var invalidationBatchHandler = function (keys) {
            keys.forEach(function (key) {
                nearCache.invalidate(key);
            });
        };
        var codec = this.createInvalidationListenerCodec(this.name, EntryEventType_1.EntryEventType.INVALIDATION);
        return this.client.getListenerService().registerListener(codec, function (m) { MapAddNearCacheEntryListenerCodec_1.MapAddNearCacheEntryListenerCodec.handle(m, invalidationHandler, invalidationBatchHandler); });
    };
    NearCachedMapProxy.prototype.createInvalidationListenerCodec = function (name, flags) {
        return {
            encodeAddRequest: function (localOnly) {
                return MapAddNearCacheEntryListenerCodec_1.MapAddNearCacheEntryListenerCodec.encodeRequest(name, flags, localOnly);
            },
            decodeAddResponse: function (msg) {
                return MapAddNearCacheEntryListenerCodec_1.MapAddNearCacheEntryListenerCodec.decodeResponse(msg).response;
            },
            encodeRemoveRequest: function (listenerId) {
                return MapRemoveEntryListenerCodec_1.MapRemoveEntryListenerCodec.encodeRequest(name, listenerId);
            }
        };
    };
    return NearCachedMapProxy;
}(MapProxy_1.MapProxy));
exports.NearCachedMapProxy = NearCachedMapProxy;
//# sourceMappingURL=NearCachedMapProxy.js.map