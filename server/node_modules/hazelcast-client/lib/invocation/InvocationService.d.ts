/// <reference types="bluebird" />
/// <reference types="node" />
import ClientConnection = require('./ClientConnection');
import ClientMessage = require('../ClientMessage');
import Address = require('../Address');
import * as Promise from 'bluebird';
import HazelcastClient from '../HazelcastClient';
export declare class Invocation {
    constructor(client: HazelcastClient, request: ClientMessage);
    client: HazelcastClient;
    invocationService: InvocationService;
    request: ClientMessage;
    partitionId: number;
    address: Address;
    deadline: Date;
    connection: ClientConnection;
    deferred: Promise.Resolver<ClientMessage>;
    invokeCount: number;
    handler: (...args: any[]) => any;
    hasPartitionId(): boolean;
}
export declare class InvocationService {
    private correlationCounter;
    private eventHandlers;
    private pending;
    private client;
    private smartRoutingEnabled;
    private readonly invocationRetryPauseMillis;
    private readonly invocationTimeoutMillis;
    private logger;
    private isShutdown;
    doInvoke: (invocation: Invocation) => void;
    constructor(hazelcastClient: HazelcastClient);
    shutdown(): void;
    invoke(invocation: Invocation): Promise<ClientMessage>;
    invokeOnConnection(connection: ClientConnection, request: ClientMessage, handler?: (...args: any[]) => any): Promise<ClientMessage>;
    invokeOnPartition(request: ClientMessage, partitionId: number): Promise<ClientMessage>;
    invokeOnTarget(request: ClientMessage, target: Address): Promise<ClientMessage>;
    invokeOnRandomTarget(request: ClientMessage): Promise<ClientMessage>;
    getInvocationTimeoutMillis(): number;
    getInvocationRetryPauseMillis(): number;
    private invokeSmart(invocation);
    private invokeNonSmart(invocation);
    private invokeOnAddress(invocation, address);
    private invokeOnPartitionOwner(invocation, partitionId);
    private send(invocation, connection);
    private write(invocation, connection);
    private notifyError(invocation, error);
    private isRetryable(invocation);
    private registerInvocation(invocation);
    removeEventHandler(id: number): void;
    processResponse(buffer: Buffer): void;
}
