"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Promise = require("bluebird");
var ClientAddMembershipListenerCodec_1 = require("../codec/ClientAddMembershipListenerCodec");
var LoggingService_1 = require("../logging/LoggingService");
var events_1 = require("events");
var ClientInfo_1 = require("../ClientInfo");
var MEMBER_ADDED = 1;
var MEMBER_REMOVED = 2;
var EMIT_MEMBER_ADDED = 'memberAdded';
var EMIT_MEMBER_REMOVED = 'memberRemoved';
var EMIT_ATTRIBUTE_CHANGE = 'memberAttributeChange';
var ATTRIBUTE_CHANGE = {
    1: 'put',
    2: 'remove'
};
var ClusterService = (function (_super) {
    __extends(ClusterService, _super);
    function ClusterService(client) {
        var _this = _super.call(this) || this;
        _this.ownerUuid = null;
        _this.uuid = null;
        _this.knownAddresses = [];
        _this.members = [];
        _this.logger = LoggingService_1.LoggingService.getLoggingService();
        _this.client = client;
        _this.members = [];
        return _this;
    }
    ClusterService.prototype.start = function () {
        this.initHeartbeatListener();
        this.initConnectionListener();
        return this.connectToCluster();
    };
    ClusterService.prototype.connectToCluster = function () {
        var _this = this;
        if (this.members.length > 0) {
            this.knownAddresses = new Array();
            this.members.forEach(function (member) {
                _this.knownAddresses.push(member.address);
            });
        }
        else {
            this.knownAddresses = this.client.getConfig().networkConfig.addresses;
        }
        var deferred = Promise.defer();
        var attemptLimit = this.client.getConfig().networkConfig.connectionAttemptLimit;
        var attemptPeriod = this.client.getConfig().networkConfig.connectionAttemptPeriod;
        this.tryAddressIndex(0, attemptLimit, attemptPeriod, deferred);
        return deferred.promise;
    };
    ClusterService.prototype.getMembers = function () {
        return this.members;
    };
    ClusterService.prototype.getSize = function () {
        return this.members.length;
    };
    ClusterService.prototype.getClientInfo = function () {
        var info = new ClientInfo_1.ClientInfo();
        info.uuid = this.uuid;
        info.localAddress = this.getOwnerConnection().getLocalAddress();
        return info;
    };
    ClusterService.prototype.initHeartbeatListener = function () {
        this.client.getHeartbeat().addListener({
            onHeartbeatStopped: this.onHeartbeatStopped.bind(this)
        });
    };
    ClusterService.prototype.initConnectionListener = function () {
        this.client.getConnectionManager().on('connectionClosed', this.onConnectionClosed.bind(this));
    };
    ClusterService.prototype.onConnectionClosed = function (connection) {
        this.logger.warn('ClusterService', 'Connection closed to ' + connection.address.toString());
        if (connection.address === this.getOwnerConnection().address) {
            this.ownerConnection = null;
            this.connectToCluster().catch(this.client.shutdown.bind(this.client));
        }
    };
    ClusterService.prototype.onHeartbeatStopped = function (connection) {
        this.logger.warn('ClusterService', connection.address.toString() + ' stopped heartbeating.');
        if (connection.getAddress() === this.ownerConnection.address) {
            this.client.getConnectionManager().destroyConnection(connection.address);
        }
    };
    ClusterService.prototype.tryAddressIndex = function (index, attemptLimit, attemptPeriod, deferred) {
        var _this = this;
        setImmediate(function () {
            if (_this.knownAddresses.length <= index) {
                attemptLimit = attemptLimit - 1;
                if (attemptLimit === 0) {
                    var error = new RangeError('Unable to connect to any of the following addresses: ' +
                        _this.knownAddresses.map(function (element) {
                            return element.toString();
                        }).join(', '));
                    deferred.reject(error);
                    return;
                }
                else {
                    setTimeout(_this.tryAddressIndex.bind(_this, 0, attemptLimit, attemptPeriod, deferred), attemptPeriod);
                }
            }
            else {
                var currentAddress = _this.knownAddresses[index];
                _this.client.getConnectionManager().getOrConnect(currentAddress, true)
                    .then(function (connection) {
                    if (connection == null) {
                        throw new Error('Could not connect to ' + currentAddress.toString());
                    }
                    _this.ownerConnection = connection;
                    _this.initMemberShipListener().then(function () {
                        deferred.resolve();
                    });
                }).catch(function (e) {
                    _this.logger.warn('ClusterService', e);
                    _this.tryAddressIndex(index + 1, attemptLimit, attemptPeriod, deferred);
                });
            }
        });
    };
    ClusterService.prototype.getOwnerConnection = function () {
        return this.ownerConnection;
    };
    ClusterService.prototype.initMemberShipListener = function () {
        var _this = this;
        var request = ClientAddMembershipListenerCodec_1.ClientAddMembershipListenerCodec.encodeRequest(false);
        var handler = function (m) {
            var handleMember = _this.handleMember.bind(_this);
            var handleMemberList = _this.handleMemberList.bind(_this);
            var handleAttributeChange = _this.handleMemberAttributeChange.bind(_this);
            ClientAddMembershipListenerCodec_1.ClientAddMembershipListenerCodec.handle(m, handleMember, handleMemberList, handleAttributeChange, null);
        };
        return this.client.getInvocationService().invokeOnConnection(this.getOwnerConnection(), request, handler)
            .then(function (resp) {
            _this.logger.trace('ClusterService', 'Registered listener with id '
                + ClientAddMembershipListenerCodec_1.ClientAddMembershipListenerCodec.decodeResponse(resp).response);
        });
    };
    ClusterService.prototype.handleMember = function (member, eventType) {
        if (eventType === MEMBER_ADDED) {
            this.logger.info('ClusterService', member.toString() + ' added to cluster');
            this.memberAdded(member);
        }
        else if (eventType === MEMBER_REMOVED) {
            this.logger.info('ClusterService', member.toString() + ' removed from cluster');
            this.memberRemoved(member);
        }
        this.client.getPartitionService().refresh();
    };
    ClusterService.prototype.handleMemberList = function (members) {
        this.members = members;
        this.client.getPartitionService().refresh();
        this.logger.info('ClusterService', 'Members received.', this.members);
    };
    ClusterService.prototype.handleMemberAttributeChange = function (uuid, key, operationType, value) {
        this.emit(EMIT_ATTRIBUTE_CHANGE, uuid, key, ATTRIBUTE_CHANGE[operationType], value);
    };
    ClusterService.prototype.memberAdded = function (member) {
        this.members.push(member);
        this.emit(EMIT_MEMBER_ADDED, member);
    };
    ClusterService.prototype.memberRemoved = function (member) {
        this.members.splice(this.members.indexOf(member), 1);
        this.client.getConnectionManager().destroyConnection(member.address);
        this.emit(EMIT_MEMBER_REMOVED, member);
    };
    return ClusterService;
}(events_1.EventEmitter));
module.exports = ClusterService;
//# sourceMappingURL=ClusterService.js.map