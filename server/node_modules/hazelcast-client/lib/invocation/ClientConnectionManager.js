"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Promise = require("bluebird");
var LoggingService_1 = require("../logging/LoggingService");
var events_1 = require("events");
var HazelcastError_1 = require("../HazelcastError");
var ClientConnection = require("./ClientConnection");
var ConnectionAuthenticator = require("./ConnectionAuthenticator");
var EMIT_CONNECTION_CLOSED = 'connectionClosed';
var EMIT_CONNECTION_OPENED = 'connectionOpened';
var ClientConnectionManager = (function (_super) {
    __extends(ClientConnectionManager, _super);
    function ClientConnectionManager(client) {
        var _this = _super.call(this) || this;
        _this.pendingConnections = {};
        _this.logger = LoggingService_1.LoggingService.getLoggingService();
        _this.establishedConnections = {};
        _this.client = client;
        return _this;
    }
    ClientConnectionManager.prototype.getActiveConnections = function () {
        return this.establishedConnections;
    };
    ClientConnectionManager.prototype.getOrConnect = function (address, ownerConnection) {
        var _this = this;
        if (ownerConnection === void 0) { ownerConnection = false; }
        var addressIndex = address.toString();
        var result = Promise.defer();
        var establishedConnection = this.establishedConnections[addressIndex];
        if (establishedConnection) {
            result.resolve(establishedConnection);
            return result.promise;
        }
        var pendingConnection = this.pendingConnections[addressIndex];
        if (pendingConnection) {
            return pendingConnection.promise;
        }
        this.pendingConnections[addressIndex] = result;
        var clientConnection = new ClientConnection(this.client.getConnectionManager(), address, this.client.getConfig().networkConfig);
        clientConnection.connect().then(function () {
            clientConnection.registerResponseCallback(function (data) {
                _this.client.getInvocationService().processResponse(data);
            });
        }).then(function () {
            return _this.authenticate(clientConnection, ownerConnection);
        }).then(function () {
            _this.establishedConnections[clientConnection.address.toString()] = clientConnection;
            _this.onConnectionOpened(clientConnection);
            result.resolve(clientConnection);
        }).catch(function (e) {
            result.resolve(null);
        }).finally(function () {
            delete _this.pendingConnections[addressIndex];
        });
        var connectionTimeout = this.client.getConfig().networkConfig.connectionTimeout;
        if (connectionTimeout !== 0) {
            return result.promise.timeout(connectionTimeout, new HazelcastError_1.HazelcastError('Connection timed-out'));
        }
        return result.promise;
    };
    ClientConnectionManager.prototype.destroyConnection = function (address) {
        var addressStr = address.toString();
        if (this.pendingConnections.hasOwnProperty(addressStr)) {
            this.pendingConnections[addressStr].reject(null);
        }
        if (this.establishedConnections.hasOwnProperty(addressStr)) {
            var conn = this.establishedConnections[addressStr];
            delete this.establishedConnections[addressStr];
            conn.close();
            this.onConnectionClosed(conn);
        }
    };
    ClientConnectionManager.prototype.shutdown = function () {
        for (var pending in this.pendingConnections) {
            this.pendingConnections[pending].reject(new HazelcastError_1.ClientNotActiveError('Client is shutting down!'));
        }
        for (var conn in this.establishedConnections) {
            this.establishedConnections[conn].close();
        }
    };
    ClientConnectionManager.prototype.onConnectionClosed = function (connection) {
        this.emit(EMIT_CONNECTION_CLOSED, connection);
    };
    ClientConnectionManager.prototype.onConnectionOpened = function (connection) {
        this.emit(EMIT_CONNECTION_OPENED, connection);
    };
    ClientConnectionManager.prototype.authenticate = function (connection, ownerConnection) {
        var authenticator = new ConnectionAuthenticator(connection, this.client);
        return authenticator.authenticate(ownerConnection);
    };
    return ClientConnectionManager;
}(events_1.EventEmitter));
module.exports = ClientConnectionManager;
//# sourceMappingURL=ClientConnectionManager.js.map