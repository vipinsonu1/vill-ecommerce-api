"use strict";
var ClientPingCodec_1 = require("./codec/ClientPingCodec");
var LoggingService_1 = require("./logging/LoggingService");
var PROPERTY_HEARTBEAT_INTERVAL = 'hazelcast.client.heartbeat.interval';
var PROPERTY_HEARTBEAT_TIMEOUT = 'hazelcast.client.heartbeat.timeout';
var Heartbeat = (function () {
    function Heartbeat(client) {
        this.listeners = [];
        this.logger = LoggingService_1.LoggingService.getLoggingService();
        this.client = client;
        this.heartbeatInterval = this.client.getConfig().properties[PROPERTY_HEARTBEAT_INTERVAL];
        this.heartbeatTimeout = this.client.getConfig().properties[PROPERTY_HEARTBEAT_TIMEOUT];
    }
    Heartbeat.prototype.start = function () {
        this.timer = setTimeout(this.heartbeatFunction.bind(this), this.heartbeatInterval);
    };
    Heartbeat.prototype.cancel = function () {
        clearTimeout(this.timer);
    };
    Heartbeat.prototype.addListener = function (heartbeatListener) {
        this.listeners.push(heartbeatListener);
    };
    Heartbeat.prototype.heartbeatFunction = function () {
        var _this = this;
        var estConnections = this.client.getConnectionManager().establishedConnections;
        for (var address in estConnections) {
            if (estConnections[address]) {
                var conn = estConnections[address];
                var timeSinceLastRead = new Date().getTime() - conn.lastRead;
                if (timeSinceLastRead > this.heartbeatTimeout) {
                    if (conn.heartbeating) {
                        setImmediate(this.onHeartbeatStopped.bind(this), conn);
                    }
                }
                if (timeSinceLastRead > this.heartbeatInterval) {
                    var req = ClientPingCodec_1.ClientPingCodec.encodeRequest();
                    this.client.getInvocationService().invokeOnConnection(conn, req)
                        .catch(function (error) {
                        _this.logger.warn('HeartbeatService', error);
                    });
                }
                else {
                    if (!conn.heartbeating) {
                        setImmediate(this.onHeartbeatRestored.bind(this), conn);
                    }
                }
            }
        }
        this.timer = setTimeout(this.heartbeatFunction.bind(this), this.heartbeatInterval);
    };
    Heartbeat.prototype.onHeartbeatStopped = function (connection) {
        var _this = this;
        connection.heartbeating = false;
        this.logger.warn('HeartbeatService', 'Heartbeat stopped on ' + connection.address.toString());
        this.listeners.forEach(function (listener) {
            if (listener.hasOwnProperty('onHeartbeatStopped')) {
                setImmediate(listener.onHeartbeatStopped.bind(_this), connection);
            }
        });
    };
    Heartbeat.prototype.onHeartbeatRestored = function (connection) {
        var _this = this;
        connection.heartbeating = true;
        this.logger.warn('HeartbeatService', 'Heartbeat restored on ' + connection.address.toString());
        this.listeners.forEach(function (listener) {
            if (listener.hasOwnProperty('onHeartbeatRestored')) {
                setImmediate(listener.onHeartbeatRestored.bind(_this), connection);
            }
        });
    };
    return Heartbeat;
}());
module.exports = Heartbeat;
//# sourceMappingURL=HeartbeatService.js.map