"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Long = require("long");
var Predicate_1 = require("./core/Predicate");
var assert = require("assert");
function assertNotNull(v) {
    assert.notEqual(v, null, 'Non null value expected.');
}
exports.assertNotNull = assertNotNull;
function assertArray(x) {
    assert(Array.isArray(x), 'Should be array.');
}
exports.assertArray = assertArray;
function shuffleArray(array) {
    var randomIndex;
    var temp;
    for (var i = array.length; i > 1; i--) {
        randomIndex = Math.floor(Math.random() * i);
        temp = array[i - 1];
        array[i - 1] = array[randomIndex];
        array[randomIndex] = temp;
    }
}
exports.shuffleArray = shuffleArray;
function assertNotNegative(v, message) {
    if (message === void 0) { message = 'The value cannot be negative.'; }
    assert(v >= 0, message);
}
exports.assertNotNegative = assertNotNegative;
function getType(obj) {
    assertNotNull(obj);
    if (Long.isLong(obj)) {
        return 'long';
    }
    else {
        var t = typeof obj;
        if (t !== 'object') {
            return t;
        }
        else {
            return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
        }
    }
}
exports.getType = getType;
function enumFromString(enumType, value) {
    return enumType[value];
}
exports.enumFromString = enumFromString;
function getSortedQueryResultSet(list, predicate) {
    if (list.length === 0) {
        return list;
    }
    var comparatorObject = predicate.getComparator();
    if (comparatorObject == null) {
        comparatorObject = createComparator(predicate.getIterationType());
    }
    list.sort(comparatorObject.sort.bind(comparatorObject));
    var nearestAnchorEntry = (predicate == null) ? null : predicate.getNearestAnchorEntry();
    var nearestPage = nearestAnchorEntry[0];
    var page = predicate.getPage();
    var pageSize = predicate.getPageSize();
    var begin = pageSize * (page - nearestPage - 1);
    var size = list.length;
    if (begin > size) {
        return [];
    }
    var end = begin + pageSize;
    if (end > size) {
        end = size;
    }
    setAnchor(list, predicate, nearestPage);
    var iterationType = predicate.getIterationType();
    return list.slice(begin, end).map(function (item) {
        switch (iterationType) {
            case Predicate_1.IterationType.ENTRY: return item;
            case Predicate_1.IterationType.KEY: return item[0];
            case Predicate_1.IterationType.VALUE: return item[1];
        }
    });
}
exports.getSortedQueryResultSet = getSortedQueryResultSet;
function copyObjectShallow(obj) {
    if (obj === undefined || obj === null) {
        return obj;
    }
    if (typeof obj === 'object') {
        var newObj = {};
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
                newObj[prop] = obj[prop];
            }
        }
        return newObj;
    }
    assert(false, 'Object should be undefined or type of object.');
}
exports.copyObjectShallow = copyObjectShallow;
function createComparator(iterationType) {
    var object = {
        sort: function (a, b) {
            return 0;
        }
    };
    switch (iterationType) {
        case Predicate_1.IterationType.KEY:
            object.sort = function (e1, e2) { return e1[0] < e2[0] ? -1 : +(e1[0] > e2[0]); };
            break;
        case Predicate_1.IterationType.ENTRY:
            object.sort = function (e1, e2) { return e1[1] < e2[1] ? -1 : +(e1[1] > e2[1]); };
            break;
        case Predicate_1.IterationType.VALUE:
            object.sort = function (e1, e2) { return e1[1] < e2[1] ? -1 : +(e1[1] > e2[1]); };
            break;
    }
    return object;
}
function setAnchor(list, predicate, nearestPage) {
    assert(list.length > 0);
    var size = list.length;
    var pageSize = predicate.getPageSize();
    var page = predicate.getPage();
    for (var i = pageSize; i <= size && nearestPage < page; i += pageSize) {
        var anchor = list[i - 1];
        nearestPage++;
        predicate.setAnchor(nearestPage, anchor);
    }
}
//# sourceMappingURL=Util.js.map